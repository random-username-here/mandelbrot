![Мандельброт](result.png)

# Быстрое вычисление множества Мандельброта

Данная лабораторная посвящена реализации вычислителя 
множества Мандельброта на C. Что и было сделано.


## Реализация

### Метод построения

Здесь использвовался простой алгоритм построения, без сглаживания.
Берём начальную точку в $`z_0 \in \mathbb{C}`$, и считаем рекуррентную
последовательность $`z_{n+1} = z_n^2 + z_0`$. Если $`|z_n| > 10`$, то 
завершаем рассчёт. Полученное таким образом $`n`$ определяет цвет.

Визуализатор преобразовывает это $`n`$ в цвет несколькими способами,
в зависимости от выбранной палитры. При замере времени считаются только $`n`$.

Всего три реализации:

 - `simple` -- простая реализация без каких-либо ручных оптимизаций,
    относительно которой будет считаться прирост скорости.

 - `avx` -- версия, использующая `avx`-интринсики

 - `avx2` -- использует `avx2`

Все они в `src/gen/`.

### Визуализатор

Программа, отображающая множество с помощью фреймбуффера на `SDL2`.
Компилируется так:

```bash
$ make viewer
$ ./viewer
```

Клавиши:

 - стрелки для движения
 - `PgUp`/`PgDn` для приближения/отдаления
 - `g` для смены реализцаии
 - `c` для смены палитры

### Бенчмаркер

Это программа, замеряющая производительность реализаций рассчёта $`n`$ для
каждого пикселя на изображении. Компилируется так:


```bash
$ make benchmark
$ ./benchmark ОПЦИИ
```

Считает кадр размера $1024 \times 768$ пикселей (такой же размер окна у просмотрщика),
с центром в $(0, 0)$ и шириной окна $2$ (то есть левый край окна это $x = -1$,
правый $x = 1$).

Замер работает так: считаем кадр, кидаем время рассчёта в кольцевой буффер длинны N.
Когда весь буффер заполнен, и время в нём имеет небольшой относительный разброс,
то мы признаём алгоритм достаточно стабильным и выводим результаты.

Соответственно, опции таковы:

 - `-g GEN` -- какую реализацию будем замерять: `simple`, `avx` или `avx2`
 - `-m MSR` -- размер буффера, то есть сколько запусков мы будем усреднять
 - `-v VAR` -- алгоритм считается стабильным, если за последние $`MSR`$ разов
    $`t_{min} * VAR >= t_{max}`$.

 - `-h` -- help

## Измерения

TODO, я переписал программу, нужно будет снова их провести

## Зависимости

Использует `SDL2` и `avx/avx2` интринсики, так что нужен процессор `x86-64`.

## Ссылки

 - Используемый безымянный шрифт -- https://courses.cs.washington.edu/courses/cse457/98a/tech/OpenGL/font.c

